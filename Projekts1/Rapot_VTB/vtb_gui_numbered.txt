0001: """Simple GUI orchestrating the VTB report import and analysis pipeline."""
0002: 
0003: from __future__ import annotations
0004: 
0005: import contextlib
0006: import importlib.util
0007: import logging
0008: import queue
0009: import sys
0010: import threading
0011: import tkinter as tk
0012: from pathlib import Path
0013: from tkinter import filedialog, messagebox
0014: from tkinter.scrolledtext import ScrolledText
0015: 
0016: ROOT_DIR = Path(__file__).resolve().parent
0017: READ_SCRIPT = ROOT_DIR / "ReadOT4ET.py"
0018: HTTP_SCRIPT = ROOT_DIR / "HTTP-Req_PORTFOLIO.py"
0019: ANALIZ_SCRIPT = ROOT_DIR / "ANALIZ_VTB.py"
0020: 
0021: 
0022: def _load_module(module_name: str, script_path: Path):
0023:     if not script_path.exists():
0025:     spec = importlib.util.spec_from_file_location(module_name, script_path)
0026:     if spec is None or spec.loader is None:
0028:     module = importlib.util.module_from_spec(spec)
0029:     spec.loader.exec_module(module)
0030:     return module
0031: 
0032: 
0033: READ_MODULE = _load_module("vtb_read_module", READ_SCRIPT)
0034: HTTP_MODULE = _load_module("vtb_http_module", HTTP_SCRIPT)
0035: ANALIZ_MODULE = _load_module("vtb_analiz_module", ANALIZ_SCRIPT)
0036: 
0037: 
0038: class _QueueWriter:
0039:     """File-like object that forwards writes to a queue."""
0040: 
0041:     def __init__(self, target_queue: queue.Queue[str]):
0042:         self.queue = target_queue
0043: 
0044:     def write(self, message: str) -> None:
0045:         if message:
0046:             self.queue.put(message)
0047: 
0048:     def flush(self) -> None:  # pragma: no cover - required for file-like API
0049:         pass
0050: 
0051: 
0052: class _QueueLoggingHandler(logging.Handler):
0053:     """Logging handler that mirrors log records into the GUI log queue."""
0054: 
0055:     def __init__(self, target_queue: queue.Queue[str]):
0056:         super().__init__()
0057:         self.queue = target_queue
0058: 
0059:     def emit(self, record: logging.LogRecord) -> None:
0060:         try:
0061:             msg = self.format(record)
0062:         except Exception:  # pragma: no cover - fallback mirrors std logging
0063:             self.handleError(record)
0064:             return
0065:         self.queue.put(msg + "\n")
0066: 
0067: 
0068: @contextlib.contextmanager
0069: def redirect_output(target_queue: queue.Queue[str]):
0070:     """Redirect stdout/stderr and logging records into the GUI queue."""
0071: 
0072:     writer = _QueueWriter(target_queue)
0073:     original_stdout, original_stderr = sys.stdout, sys.stderr
0074:     sys.stdout = writer
0075:     sys.stderr = writer
0076: 
0077:     logging_handler = _QueueLoggingHandler(target_queue)
0078:     logging_handler.setFormatter(logging.Formatter("%(asctime)s | %(levelname)s | %(message)s"))
0079:     root_logger = logging.getLogger()
0080:     root_logger.addHandler(logging_handler)
0081:     try:
0082:         yield
0083:     finally:
0084:         root_logger.removeHandler(logging_handler)
0085:         sys.stdout = original_stdout
0086:         sys.stderr = original_stderr
0087: 
0088: 
0089: def run_import(path: Path) -> None:
0090:     """Run ReadOT4ET pipeline for a single file."""
0091: 
0092:     if not path.is_file():
0094: 
0095:     READ_MODULE.ensure_dirs()
0096:     conn = READ_MODULE.connect_db()
0097:     READ_MODULE.init_db(conn)
0098:     try:
0099:         total_rows, inserted_rows = READ_MODULE.process_file(str(path), conn)
0100:     finally:
0101:         conn.close()
0102: 
0103:     print(
0106:     )
0107: 
0108: 
0109: def run_http_pipeline() -> None:
0110:     """Run HTTP data enrichment pipeline."""
0111: 
0112:     HTTP_MODULE.main()
0113: 
0114: 
0115: def run_analysis() -> None:
0116:     """Run final analytics/telegram pipeline."""
0117: 
0118:     ANALIZ_MODULE.main()
0119: 
0120: 
0121: class VTBApp(tk.Tk):
0122:     """Tkinter application that orchestrates the workflow."""
0123: 
0124:     def __init__(self) -> None:
0125:         super().__init__()
0126:         self.title("VTB Portfolio Assistant")
0127:         self.geometry("960x640")
0128: 
0129:         self.file_var = tk.StringVar()
0130:         self.file_var.trace_add("write", self._on_file_change)
0131: 
0132:         self.log_queue: queue.Queue[str] = queue.Queue()
0133:         self._is_running = False
0134: 
0135:         self._build_ui()
0136:         self._process_log_queue()
0137: 
0138:     def _build_ui(self) -> None:
0139:         top_frame = tk.Frame(self)
0140:         top_frame.pack(fill="x", padx=10, pady=10)
0141: 
0142:         tk.Label(top_frame, text="Файл отчёта:").pack(side="left")
0143:         self.file_entry = tk.Entry(top_frame, textvariable=self.file_var, width=80)
0144:         self.file_entry.pack(side="left", padx=(5, 5), expand=True, fill="x")
0145: 
0146:         tk.Button(top_frame, text="Обзор...", command=self._select_file).pack(side="left")
0147: 
0148:         buttons_frame = tk.Frame(self)
0149:         buttons_frame.pack(fill="x", padx=10, pady=(0, 10))
0150: 
0151:         self.btn_import_all = tk.Button(
0152:             buttons_frame,
0153:             text="Импорт и анализ",
0154:             command=lambda: self._start_pipeline(include_import=True),
0155:             state="disabled",
0156:             width=20,
0157:         )
0158:         self.btn_import_all.pack(side="left", padx=(0, 10))
0159: 
0160:         self.btn_analyze = tk.Button(
0161:             buttons_frame,
0162:             text="Анализ",
0163:             command=lambda: self._start_pipeline(include_import=False),
0164:             width=20,
0165:         )
0166:         self.btn_analyze.pack(side="left")
0167: 
0168:         log_frame = tk.LabelFrame(self, text="Журнал выполнения")
0169:         log_frame.pack(fill="both", expand=True, padx=10, pady=(0, 10))
0170: 
0171:         self.log_text = ScrolledText(log_frame, state="disabled", wrap="word")
0172:         self.log_text.pack(fill="both", expand=True)
0173: 
0174:     def _select_file(self) -> None:
0175:         file_path = filedialog.askopenfilename(
0176:             title="Выберите отчёт VTB",
0177:             filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")],
0178:         )
0179:         if file_path:
0180:             self.file_var.set(file_path)
0181: 
0182:     def _on_file_change(self, *_args) -> None:
0183:         if self.file_var.get().strip():
0184:             self.btn_import_all.config(state="normal")
0185:         else:
0186:             self.btn_import_all.config(state="disabled")
0187: 
0188:     def _start_pipeline(self, include_import: bool) -> None:
0189:         if self._is_running:
0190:             return
0191: 
0192:         selected_file: Path | None = None
0193:         if include_import:
0194:             path_text = self.file_var.get().strip()
0195:             if not path_text:
0196:                 messagebox.showwarning("Файл не выбран", "Пожалуйста, выберите файл для импорта.")
0197:                 return
0198:             selected_file = Path(path_text)
0199:             if not selected_file.is_file():
0201:                 return
0202: 
0203:         self._set_running(True)
0204:         thread = threading.Thread(
0205:             target=self._run_pipeline,
0206:             args=(include_import, selected_file),
0207:             daemon=True,
0208:         )
0209:         thread.start()
0210: 
0211:     def _run_pipeline(self, include_import: bool, selected_file: Path | None) -> None:
0212:         error_message: str | None = None
0213:         try:
0214:             with redirect_output(self.log_queue):
0215:                 if include_import and selected_file:
0217:                     run_import(selected_file)
0218:                 print("Запуск HTTP_Req_PORTFOLIO...")
0219:                 run_http_pipeline()
0220:                 print("Запуск ANALIZ_VTB...")
0221:                 run_analysis()
0222:                 print("Все шаги успешно завершены.")
0223:         except Exception as exc:  # noqa: BLE001 - surface exact exception to user
0224:             error_message = str(exc)
0226:         finally:
0227:             self.after(0, lambda: self._on_pipeline_finished(error_message))
0228: 
0229:     def _on_pipeline_finished(self, error_message: str | None) -> None:
0230:         self._set_running(False)
0231:         if error_message:
0232:             messagebox.showerror("Процесс завершился с ошибкой", error_message)
0233:         else:
0234:             messagebox.showinfo("Готово", "Пайплайн успешно завершён.")
0235: 
0236:     def _set_running(self, running: bool) -> None:
0237:         self._is_running = running
0238:         state = "disabled" if running else "normal"
0239:         self.btn_import_all.config(state=state if self.file_var.get().strip() else "disabled")
0240:         self.btn_analyze.config(state=state)
0241: 
0242:     def _process_log_queue(self) -> None:
0243:         try:
0244:             while True:
0245:                 message = self.log_queue.get_nowait()
0246:                 self._append_log(message)
0247:         except queue.Empty:
0248:             pass
0249:         finally:
0250:             self.after(100, self._process_log_queue)
0251: 
0252:     def _append_log(self, message: str) -> None:
0253:         self.log_text.configure(state="normal")
0254:         self.log_text.insert(tk.END, message)
0255:         self.log_text.see(tk.END)
0256:         self.log_text.configure(state="disabled")
0257: 
0258: 
0259: if __name__ == "__main__":
0260:     app = VTBApp()
0261:     app.mainloop()
